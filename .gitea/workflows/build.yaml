name: SPT Release Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  check-tag-exists:
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.check.outputs.proceed }}
      target_tag: ${{ steps.check.outputs.target_tag }}
    steps:
      - name: Check Tag Exists in All Repositories
        id: check
        run: |
          # The tag needs to be saved as a variable so that it can be used throughout the build process.
          TAG="3.8.0-BE-20240308"
          REPOS=("https://dev.sp-tarkov.com/SPT-AKI/Server.git" "https://dev.sp-tarkov.com/SPT-AKI/Modules.git" "https://dev.sp-tarkov.com/SPT-AKI/Launcher.git")
          PROCEED="true"
          for REPO in ${REPOS[@]}; do
            echo "Checking for tag $TAG in $REPO..."
            if ! git ls-remote --tags $REPO $TAG | grep -q $TAG; then
              echo "Tag $TAG not found in $REPO"
              PROCEED="false"
              break
            fi
          done
          echo "::set-output name=proceed::${PROCEED}"
          echo "::set-output name=target_tag::${TAG}"
        shell: bash

      - name: Tag Not Found
        if: steps.check.outputs.proceed == 'false'
        run: |
          echo "Tag not found in one or more repositories, halting workflow."
          exit 1

  build-server:
    needs: check-tag-exists
    if: needs.check-tag-exists.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    container:
      image: refringe/spt-build-node:1.0.5
    outputs:
      build_type: ${{ steps.build-type.outputs.build_type }}
    steps:
    - name: Clone
      run: |
        TARGET_TAG=${{ needs.check-tag-exists.outputs.target_tag }}
        rm -rf /workspace/refringe/Build/server
        git clone https://dev.sp-tarkov.com/SPT-AKI/Server.git --branch "${TARGET_TAG}" --depth 1 /workspace/refringe/Build/server

    - name: Pull LFS Files
      run: |
        cd /workspace/refringe/Build/server
        git lfs pull && git lfs ls-files

    - name: Runner Debug Information
      run: |
        cd /workspace/refringe/Build/server
        echo "Git version: $(git --version)"
        echo "Git LFS version: $(git-lfs --version)"
        echo "Node.js version: $(node --version)"
        echo "NPM version: $(npm --version)"
        echo "Latest Commit Hash: $(git rev-parse HEAD)"
        echo "Associated Tags: $(git tag --contains HEAD)"
        echo "Last Commit Message:" && git log -1 --pretty=%B

    - name: Cache Keys
      id: cache-keys
      run: |
        cd /workspace/refringe/Build/server
        echo "::set-output name=commit_hash::$(git rev-parse HEAD)"
        TAGS=$(git tag --contains HEAD || echo "no-tag")
        if [ -z "$TAGS" ]; then
          TAGS="no-tag"
        fi
        TAGS="${TAGS//$'\n'/-}"  # Replace newline characters with dashes
        TAGS="${TAGS//,/-}"      # Replace commas with dashes
        echo "::set-output name=tags::${TAGS}"
        echo "Commit Hash: ${{ steps.cache-keys.outputs.commit_hash }}"
        echo "Tags: ${{ steps.cache-keys.outputs.tags }}"
      shell: bash

    - name: Determine Build Type
      id: build-type
      run: |
        TAGS="${{ steps.cache-keys.outputs.tags }}"
        BUILD_TYPE="debug"  # Default
        if [[ "$TAGS" =~ -BE ]]; then
          BUILD_TYPE="bleeding"
        elif [[ "$TAGS" =~ ^(v?\d+\.\d+\.\d+)$ ]]; then
          BUILD_TYPE="release"
        fi
        echo "::set-output name=build_type::${BUILD_TYPE}"
      shell: bash

    - name: Build Cache
      id: build-cache
      uses: actions/cache@v4
      with:
        path: /workspace/refringe/Build/server/project/build
        key: build-${{ steps.cache-keys.outputs.commit_hash }}-${{ steps.cache-keys.outputs.tags }}-${{ steps.build-type.outputs.build_type }}
        restore-keys: |
          build-${{ steps.cache-keys.outputs.commit_hash }}-${{ steps.cache-keys.outputs.tags }}-
          build-${{ steps.cache-keys.outputs.commit_hash }}-
          build-

    - name: Install Dependencies
      if: steps.build-cache.outputs.cache-hit != 'true'
      run: |
        cd /workspace/refringe/Build/server/project
        npm install

    - name: Build Server
      if: steps.build-cache.outputs.cache-hit != 'true'
      run: |
        cd /workspace/refringe/Build/server/project
        BUILD_TYPE="${{ steps.build-type.outputs.build_type }}"
        echo "Running build for $BUILD_TYPE"
        npm run build:$BUILD_TYPE -- --arch=x64 --platform=win32
        printf "\nBuilt!\n\n"
        tree -C /workspace/refringe/Build/server/project/build
      shell: bash

    - name: Artifact Server
      uses: actions/upload-artifact@v3
      with:
        name: server-artifact
        path: /workspace/refringe/Build/server/project/build/
        compression-level: 0
        retention-days: 1
        overwrite: true

  build-modules:
    needs: check-tag-exists
    if: needs.check-tag-exists.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    container:
      image: refringe/spt-build-dotnet:1.0.0
    outputs:
      spt_version: ${{ steps.extract-client-version.outputs.spt_version }}
      client_version: ${{ steps.extract-client-version.outputs.client_version }}
    steps:
    - name: Clone
      run: |
        TARGET_TAG=${{ needs.check-tag-exists.outputs.target_tag }}
        rm -rf /workspace/refringe/Build/modules
        git clone https://dev.sp-tarkov.com/SPT-AKI/Modules.git --branch "${TARGET_TAG}" --depth 1 /workspace/refringe/Build/modules

    - name: Fetch Server Core Config
      run: |
        TARGET_TAG=${{ needs.check-tag-exists.outputs.target_tag }}
        rm -rf /workspace/refringe/Build/server-core
        git init /workspace/refringe/Build/server-core
        cd /workspace/refringe/Build/server-core
        git remote add origin https://dev.sp-tarkov.com/SPT-AKI/Server.git
        git config core.sparseCheckout true
        echo "project/assets/configs/core.json" >> .git/info/sparse-checkout
        git fetch --depth=1 origin "${TARGET_TAG}"
        git checkout FETCH_HEAD
        ls -la project/assets/configs
      shell: bash

    - name: Extract Client Version
      id: extract-client-version
      run: |
        cd /workspace/refringe/Build/server-core/project/assets/configs
        SPT_VERSION=$(jq -r '.akiVersion' core.json)
        FULL_VERSION=$(jq -r '.compatibleTarkovVersion' core.json)
        CLIENT_VERSION=${FULL_VERSION##*.}
        echo "Extracted Client Version: $CLIENT_VERSION"
        echo "::set-output name=client_version::${CLIENT_VERSION}"
        echo "::set-output name=spt_version::${SPT_VERSION}"
      shell: bash

    - name: Download Client Module Package
      run: |
        DIR_MANAGED="/workspace/refringe/Build/modules/project/Shared/Managed"
        DOWNLOAD_PATH="$DIR_MANAGED/${{ steps.extract-client-version.outputs.client_version }}.zip"
        DOWNLOAD_URL="$MODULE_DOMAIN/${{ steps.extract-client-version.outputs.client_version }}.zip"
        echo "Downloading Client Module Package from $DOWNLOAD_URL to $DOWNLOAD_PATH"
        mkdir -p "$DIR_MANAGED"
        wget -q -O "$DOWNLOAD_PATH" "$DOWNLOAD_URL" || {
          echo "Failed to download the module package."
          exit 1
        }
        if [ ! -s "$DOWNLOAD_PATH" ]; then
          echo "The module package does not exist or is empty."
          exit 1
        fi
        echo "Download Successful: $DOWNLOAD_PATH"
      shell: bash
      env:
        MODULE_DOMAIN: ${{ secrets.MODULE_DOMAIN }}

    - name: Decompress Client Module Package
      run: |
        cd /workspace/refringe/Build/modules/project/Shared/Managed
        7z x ${{ steps.extract-client-version.outputs.client_version }}.zip -aoa
        echo "Client module package decompressed."
      shell: bash

    - name: Delete Client Module Package
      run: |
        cd /workspace/refringe/Build/modules/project/Shared/Managed
        rm -f ${{ steps.extract-client-version.outputs.client_version }}.zip
        echo "Client module package deleted."
      shell: bash

    - name: Build Modules
      run: |
        cd /workspace/refringe/Build/modules/project
        dotnet build
        printf "\nBuilt!\n\n"
        tree /workspace/refringe/Build/modules/project/Build
      shell: bash

    - name: Artifact Modules
      uses: actions/upload-artifact@v3
      with:
        name: modules-artifact
        path: /workspace/refringe/Build/modules/project/Build
        compression-level: 0
        retention-days: 1
        overwrite: true

  build-launcher:
    needs: check-tag-exists
    if: needs.check-tag-exists.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    container:
      image: refringe/spt-build-dotnet:1.0.0
    steps:
    - name: Clone
      run: |
        TARGET_TAG=${{ needs.check-tag-exists.outputs.target_tag }}
        rm -rf /workspace/refringe/Build/launcher
        git clone https://dev.sp-tarkov.com/SPT-AKI/Launcher.git --branch "${TARGET_TAG}" --depth 1 /workspace/refringe/Build/launcher

    - name: Build Launcher
      run: |
        cd /workspace/refringe/Build/launcher/project
        dotnet build
        printf "\nBuilt!\n\n"
        tree /workspace/refringe/Build/launcher/project/Build
      shell: bash

    - name: Artifact Launcher
      uses: actions/upload-artifact@v3
      with:
        name: launcher-artifact
        path: /workspace/refringe/Build/launcher/project/Build
        compression-level: 0
        retention-days: 1
        overwrite: true

  assemble-release:
    needs: [check-tag-exists, build-server, build-modules, build-launcher]
    runs-on: ubuntu-latest
    container:
      image: refringe/spt-build-node:1.0.5
    outputs:
      base_name: ${{ steps.generate-filename.outputs.base_name }}
      build_name: ${{ steps.generate-filename.outputs.build_name }}
    steps:
      - name: Clean Directory
        run: |
          rm -rf /workspace/refringe/Build/release /workspace/refringe/Build/build
          mkdir -p /workspace/refringe/Build/release

      - name: Download Server Artifact
        uses: actions/download-artifact@v3
        with:
          name: server-artifact
          path: /workspace/refringe/Build/release/

      - name: Download Modules Artifact
        uses: actions/download-artifact@v3
        with:
          name: modules-artifact
          path: /workspace/refringe/Build/release/

      - name: Download Launcher Artifact
        uses: actions/download-artifact@v3
        with:
          name: launcher-artifact
          path: /workspace/refringe/Build/release/

      - name: Clone Build Project
        uses: actions/checkout@v3
        with:
          path: /workspace/refringe/Build/build

      - name: Merge Static Assets and Dynamic Files
        run: cp -rvf /workspace/refringe/Build/build/static-assets/* /workspace/refringe/Build/release/
        shell: bash

      - name: List Release Contents
        run: tree /workspace/refringe/Build/release
        shell: bash

      - name: Generate Release Filename
        id: generate-filename
        run: |
          BUILD_TYPE=${{ needs.build-server.outputs.build_type }}
          SPT_VERSION=${{ needs.build-modules.outputs.spt_version }}
          CLIENT_VERSION=${{ needs.build-modules.outputs.client_version }}
          DATE=$(date +%Y%m%d)

          # Make BUILD_TYPE uppercase
          UPPER_BUILD_TYPE=$(echo "$BUILD_TYPE" | tr '[:lower:]' '[:upper:]')

          # Conditionally format the BASE_NAME based on BUILD_TYPE
          if [ "$BUILD_TYPE" = "release" ]; then
            BASE_NAME="SPT-${SPT_VERSION}-${CLIENT_VERSION}-${DATE}"
          else
            BASE_NAME="SPT-${UPPER_BUILD_TYPE}-${SPT_VERSION}-${CLIENT_VERSION}-${DATE}"
          fi

          echo "::set-output name=base_name::${BASE_NAME}"
          echo "::set-output name=build_name::${BASE_NAME}.7z"
        shell: bash

      - name: Artifact Release
        uses: actions/upload-artifact@v3
        with:
          name: release-artifact
          path: /workspace/refringe/Build/release
          compression-level: 0
          retention-days: 1
          overwrite: true

  publish-release:
    needs: [assemble-release, determine-build-type, build-server]
    runs-on: ubuntu-latest
    container:
      image: refringe/spt-build-node:1.0.5
    steps:
      - name: Download Release Artifact
        uses: actions/download-artifact@v3
        with:
          name: release-artifact
          path: /workspace/refringe/Build/release

      - name: Compress Release
        run: |
          cd /workspace/refringe/Build/release
          7z a -mx=9 -m0=lzma2 "../${{ needs.assemble-release.outputs.build_name }}" ./*
          echo "Release compressed as ${{ needs.assemble-release.outputs.build_name }}."
        shell: bash

      - name: Upload Release to HTTPS Source
        id: upload-https-7z
        run: |
          cd /workspace/refringe/Build/
          echo "${{ secrets.SFTP_HOST_KEY }}" > known_host
          sshpass -p "${{ secrets.SFTP_PASSWORD }}" scp -v -o "Port=${{ secrets.SFTP_PORT }}" -o "ConnectTimeout=20" -o "UserKnownHostsFile=known_host" -o "StrictHostKeyChecking=yes" "/workspace/refringe/Build/${{ needs.assemble-release.outputs.build_name }}" ${{ secrets.SFTP_USERNAME }}@${{ secrets.SFTP_HOST }}:/public
          echo "::set-output name=link_https::${{ secrets.SFTP_MIRROR_LINK }}/${{ needs.assemble-release.outputs.build_name }}"
        shell: bash

      - name: Create Torrent File
        id: torrent_create
        run: |
          BASE_NAME="${{ needs.assemble-release.outputs.base_name }}"
          BUILD_NAME="${{ needs.assemble-release.outputs.build_name }}"
          TORRENT_NAME="${BASE_NAME}.torrent"
          TORF_OUTPUT=$(/opt/venv/bin/torf --yes --out "/workspace/refringe/Build/${TORRENT_NAME}" \
            --webseed "${{ steps.upload-https-7z.outputs.link_https }}" \
            --tracker "http://open.acgnxtracker.com:80/announce,https://tracker.tamersunion.org:443/announce,http://tracker.renfei.net:8080/announce,udp://tracker.torrent.eu.org:451/announce,udp://ec2-18-191-163-220.us-east-2.compute.amazonaws.com:6969/announce" \
            --comment "Offical ${BASE_NAME} release, built by the team at sp-tarkov.com. Have fun!" \
            --creator "sp-tarkov.com" \
            --verbose \
            "/workspace/refringe/Build/${{ needs.assemble-release.outputs.build_name }}")
          MAGNET_LINK=$(echo "${TORF_OUTPUT}" | grep -oP 'Magnet\t\K.*')
          echo "::set-output name=link_magnet::${MAGNET_LINK}"
          echo "::set-output name=torrent_name::${TORRENT_NAME}"
        shell: bash

      - name: Upload Torrent to HTTPS Source
        id: upload-https-torrent
        run: |
          cd /workspace/refringe/Build/
          echo "${{ secrets.SFTP_HOST_KEY }}" > known_host
          sshpass -p "${{ secrets.SFTP_PASSWORD }}" scp -v -o "Port=${{ secrets.SFTP_PORT }}" -o "ConnectTimeout=20" -o "UserKnownHostsFile=known_host" -o "StrictHostKeyChecking=yes" "/workspace/refringe/Build/${{ steps.torrent_create.outputs.torrent_name }}" ${{ secrets.SFTP_USERNAME }}@${{ secrets.SFTP_HOST }}:/public
          echo "::set-output name=link_torrent::${{ secrets.SFTP_MIRROR_LINK }}/${{ steps.torrent_create.outputs.torrent_name }}"
        shell: bash

      - name: Clean Old HTTPS Source Releases
        run: |
          cd /workspace/refringe/Build/
          echo "${{ secrets.SFTP_HOST_KEY }}" > known_hosts

          # Creating a script for sftp to execute
          echo "cd /public" > sftp_commands.txt
          echo "ls" >> sftp_commands.txt

          # Fetch a remote list of files
          FILE_LIST=$(sshpass -p "${{ secrets.SFTP_PASSWORD }}" sftp -oBatchMode=no -oPort=${{ secrets.SFTP_PORT }} -oUserKnownHostsFile=known_hosts -oStrictHostKeyChecking=yes -b sftp_commands.txt ${{ secrets.SFTP_USERNAME }}@${{ secrets.SFTP_HOST }})

          echo "Files listed:"
          echo "$FILE_LIST"

          # Filtering and processing the file list
          echo "$FILE_LIST" | tr ' ' '\n' | grep -E 'SPT-(DEBUG|BLEEDING).*\.(7z|torrent)$' | while read filename; do
              echo "Processing file: $filename"
              # Extract date from filename
              if [[ "$filename" =~ ([0-9]{8})\.(7z|torrent)$ ]]; then
                file_date="${BASH_REMATCH[1]}"
                file_date_fmt=$(date -d "${file_date:0:4}-${file_date:4:2}-${file_date:6:2}" +%s)

                current_date=$(date +%s)
                limit_date=$(date -d "@$((current_date - 30 * 24 * 3600))" +%s)

                if [[ "$file_date_fmt" -lt "$limit_date" ]]; then
                  echo "Marked for deletion: $filename"
                  echo "rm \"/public/$filename\"" >> delete_commands.txt
                fi
              fi
          done

          # Check if there are files to delete and execute
          if [ -s delete_commands.txt ]; then
            echo "Running deletion task..."
            sshpass -p "${{ secrets.SFTP_PASSWORD }}" sftp -oBatchMode=no -oPort=${{ secrets.SFTP_PORT }} -oUserKnownHostsFile=known_hosts -oStrictHostKeyChecking=yes -b delete_commands.txt ${{ secrets.SFTP_USERNAME }}@${{ secrets.SFTP_HOST }}
          else
            echo "No old files to delete."
          fi
        shell: bash

      - name: Upload Release to Mega
        id: upload-mega
        run: |
          mega-https on
          mega-login "${{ secrets.MEGA_EMAIL }}" "${{ secrets.MEGA_PASSWORD }}"

          mega-put -c "/workspace/refringe/Build/${{ needs.assemble-release.outputs.build_name }}" "/spt-release/${{ needs.assemble-release.outputs.build_name }}"

          # Generate link and save it.
          EXPORT_OUTPUT=$(mega-export -a "/spt-release/${{ needs.assemble-release.outputs.build_name }}" -f)
          LINK_MEGA=$(echo "$EXPORT_OUTPUT" | grep -o 'https://mega.nz/file/[A-Za-z0-9#_\-]*')
          echo "::set-output name=link_mega::${LINK_MEGA}"

          mega-logout
        shell: bash

      - name: Clean Old Mega Releases
        run: |
          mega-https on
          mega-login "${{ secrets.MEGA_EMAIL }}" "${{ secrets.MEGA_PASSWORD }}"

          # List files and filter out old DEBUG or BLEEDING files
          mega-ls /spt-release | grep -E 'SPT-(DEBUG|BLEEDING).*\.7z$' | while read -r filename; do
            # Extract date from filename
            if [[ "$filename" =~ ([0-9]{8})\.7z$ ]]; then
              file_date="${BASH_REMATCH[1]}"
              file_date_fmt=$(date -d "${file_date:0:4}-${file_date:4:2}-${file_date:6:2}" +%s)

              # Get current date minus 30 days
              current_date=$(date +%s)
              limit_date=$(date -d "@$((current_date - 30 * 24 * 3600))" +%s)

              # Compare dates and delete old files
              if [[ "$file_date_fmt" -lt "$limit_date" ]]; then
                echo "Deleting old file: $filename"
                mega-rm "/spt-release/$filename"
              fi
            fi
          done

          # Remove old file versions to save space.
          mega-deleteversions -f /spt-release/*

          mega-logout
        shell: bash

      - name: Post Build Info to Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          BUILD_TYPE: ${{ needs.build-server.outputs.build_type }}
          BASE_NAME: ${{ needs.assemble-release.outputs.base_name }}
          LINK_MEGA: ${{ steps.upload-mega.outputs.link_mega }}
          LINK_HTTPS:  ${{ steps.upload-https-7z.outputs.link_https }}
          LINK_TORRENT: ${{ steps.upload-https-torrent.outputs.link_torrent }}
          BUILD_NAME: ${{ needs.assemble-release.outputs.build_name }}
        run: |
          cd /workspace/refringe/Build/
          FOOTER_MESSAGES=("You look great today!" "Powered by coffee" "Did you remember to hydrate today?" "Have you tried turning it off and on again?" "In Chomp we trust" "Beep boop, I'm a bot" "Keep calm and commit your code" "May the source be with you" "Go to bed, Terk" "Please direct all support requests to Drakia" "Meaw")
          FOOTER_MESSAGE="${FOOTER_MESSAGES[$RANDOM % ${#FOOTER_MESSAGES[@]}]}"
          TIMESTAMP=$(date --iso-8601=seconds)
          FILE_SIZE_MB=$(stat -c %s "$BUILD_NAME" | awk '{print $1 / 1024 / 1024 " MB"}')
          FILE_HASH=$(sha256sum "$BUILD_NAME" | awk '{print $1}')

          if [ "$BUILD_TYPE" == "bleeding" ]; then
            EMBED_COLOR=14423100
            EMBED_TITLE="A New BLEEDING Build Released"
            EMBED_DESCRIPTION=$'A new bleeding build is now available for download. Mods are disabled for bleeding builds. 7-Zip is *required* to extract the release.'
          elif [ "$BUILD_TYPE" == "debug" ]; then
            EMBED_COLOR=5789784
            EMBED_TITLE="New DEBUG Build Available"
            EMBED_DESCRIPTION=$'A new debug build is now available for download. Mods are disabled for debug builds. 7-Zip is *required* to extract the release.'
          else
            EMBED_COLOR=1374720
            EMBED_TITLE="Release Build Now Available"
            EMBED_DESCRIPTION=$'A new stable release build is now ready for download. 7-Zip is *required* to extract the release.'
          fi
          EMBED_DESCRIPTION+=$'\n\n**Build Name:**\n'"${BASE_NAME}"$'\n\nðŸš€ **Primary Download Link:**\n'"${LINK_MEGA}"$'\n\nðŸ”— **Torrent Link:**\n'"${LINK_TORRENT}"$'\n\nðŸ“¦ **File Size:** '"${FILE_SIZE_MB}"$'\nðŸ”’ **SHA-256 Hash:** '"${FILE_HASH}"$'\n\n**ðŸŒ Mirrors:**\n\nIn order to conserve bandwidth, please consider using the *above* methods to download the release. If you have issues using those methods, you are free to download using any of the following HTTP mirrors.\n\nWhile the links *below* are not secret, **do not advertise them**. The primary MEGA link or torrent should be used to advertise any downloads.\n\n'"${LINK_HTTPS}"

          jq -n \
            --arg EMBED_TITLE "$EMBED_TITLE" \
            --arg EMBED_DESCRIPTION "$EMBED_DESCRIPTION" \
            --arg LINK_MEGA "$LINK_MEGA" \
            --argjson EMBED_COLOR $EMBED_COLOR \
            --arg FOOTER_MESSAGE "$FOOTER_MESSAGE" \
            --arg TIMESTAMP "$TIMESTAMP" \
            '{
              "username": "BuildBot",
              "avatar_url": "https://i.imgur.com/28JJJec.png",
              "content": "âœ¨ **New Build Available!** âœ¨ (THIS IS A TEST)",
              "embeds": [
                {
                  "title": $EMBED_TITLE,
                  "description": $EMBED_DESCRIPTION,
                  "url": $LINK_MEGA,
                  "color": $EMBED_COLOR,
                  "footer": {
                    "text": $FOOTER_MESSAGE
                  },
                  "timestamp": $TIMESTAMP
                }
              ]
            }' > payload_discord.json

          echo "Payload Generated:"
          cat payload_discord.json

          echo "Sending Payload..."
          curl -H "Content-Type: application/json" \
            -X POST \
            --data-binary @payload_discord.json \
            $DISCORD_WEBHOOK_URL
        shell: bash
